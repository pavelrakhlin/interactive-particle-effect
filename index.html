<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethereal Particle Hero</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff; /* Deep dark background like Antigravity */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            perspective: 1000px; /* Enable 3D perspective */
        }

        canvas {
            display: block;
            transform-style: preserve-3d;
            transition: transform 0.1s ease-out; /* Smooth tilt */
        }

        .hero-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            pointer-events: none; /* Let clicks pass through to the canvas */
            z-index: 1;
        }

        h1 {
            font-size: 4rem;
            font-weight: 200;
            letter-spacing: -1px;
            margin: 0;
            opacity: 0.9;
        }
        
        p {
            font-weight: 300;
            color: #888;
        }
    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>

    <script>
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });

        let particles = [];
        const mouse = { x: null, y: null, radius: 120 };
        const mouseRadiusSq = mouse.radius * mouse.radius;

        const sphere = {
            radius: 0,
            fov: 800,
            spinY: 0.0007,
            spinX: 0.000225
        };
        const performanceSettings = {
            minCount: 1320,
            maxCount: 5775
        };

        // --- Pre-rendered particle sprites (one per depth bucket) ---
        const DEPTH_BUCKETS = 32;
        const IRIDESCENT_PHASES = 12;
        const spriteCache = [];

        function buildSpriteCache() {
            spriteCache.length = 0;
            for (let phase = 0; phase < IRIDESCENT_PHASES; phase++) {
                const phaseSprites = [];
                const phaseT = phase / IRIDESCENT_PHASES;
                for (let i = 0; i < DEPTH_BUCKETS; i++) {
                    const depth = i / (DEPTH_BUCKETS - 1);
                    const hue = 250 + depth * 42 + phaseT * 120;
                    const saturation = 82 + depth * 10;
                    const lightness = 20 + depth * 24;
                    const alpha = .7 + depth * .1;

                    // Core dot radius in the sprite (we'll scale via drawImage)
                    const coreR = 4;
                    const glowR = coreR * 2.5;
                    const size = glowR * 2;

                    const offscreen = document.createElement('canvas');
                    offscreen.width = size;
                    offscreen.height = size;
                    const offCtx = offscreen.getContext('2d');

                    // Soft glow via radial gradient (replaces expensive shadowBlur)
                    const grad = offCtx.createRadialGradient(glowR, glowR, 0, glowR, glowR, glowR);
                    const glowAlpha = (0.17 + depth * 0.2) * alpha;
                    grad.addColorStop(0, `hsla(${hue}, ${saturation}%, 68%, ${glowAlpha})`);
                    grad.addColorStop(0.35, `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.62})`);
                    grad.addColorStop(1, `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`);
                    offCtx.fillStyle = grad;
                    offCtx.fillRect(0, 0, size, size);

                    // Solid core
                    offCtx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                    offCtx.beginPath();
                    offCtx.arc(glowR, glowR, coreR, 0, Math.PI * 2);
                    offCtx.fill();

                    phaseSprites.push({ canvas: offscreen, half: glowR });
                }
                spriteCache.push(phaseSprites);
            }
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            sphere.radius = Math.min(canvas.width, canvas.height) * 0.68;
            buildSpriteCache();
            initParticles();
        }

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(resize, 100);
        });
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        // --- Flat arrays for particle data (better cache locality) ---
        let pX, pY, pZ, bX, bY, bZ, pDensity;
        let particleCount = 0;
        const BASE_SIZE = 0.30;
        const surfaceEffect = {
            bulge: 0.028,
            ripple: 0.022,
            frequency: 9.5,
            speed: 1.35,
            twist: 2.2
        };

        function initParticles() {
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));
            const estimated = Math.floor((sphere.radius * sphere.radius) / 75);
            const count = Math.min(
                performanceSettings.maxCount,
                Math.max(performanceSettings.minCount, estimated)
            );
            particleCount = count;

            pX = new Float32Array(count);
            pY = new Float32Array(count);
            pZ = new Float32Array(count);
            bX = new Float32Array(count);
            bY = new Float32Array(count);
            bZ = new Float32Array(count);
            pDensity = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                const t = i / (count - 1);
                const y = 1 - (t * 2);
                const ringRadius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;

                const x = Math.cos(theta) * ringRadius * sphere.radius;
                const py = y * sphere.radius;
                const z = Math.sin(theta) * ringRadius * sphere.radius;

                pX[i] = bX[i] = x;
                pY[i] = bY[i] = py;
                pZ[i] = bZ[i] = z;
                pDensity[i] = (Math.random() * 0.9) + 0.6;
            }
        }

        function animate() {
            const W = canvas.width;
            const H = canvas.height;
            const halfW = W * 0.5;
            const halfH = H * 0.5;
            const fov = sphere.fov;
            const sR = sphere.radius;
            const sR2 = sR * 2;
            const timeSec = performance.now() * 0.001;

            // Clear with background color (alpha:false context, no compositing overhead)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, W, H);

            const cosY = Math.cos(sphere.spinY);
            const sinY = Math.sin(sphere.spinY);
            const cosX = Math.cos(sphere.spinX);
            const sinX = Math.sin(sphere.spinX);

            const hasMouse = mouse.x !== null && mouse.y !== null;
            const mx = mouse.x;
            const my = mouse.y;
            const mRSq = mouseRadiusSq;
            const mR = mouse.radius;

            const n = particleCount;

            for (let i = 0; i < n; i++) {
                // --- Rotate current position ---
                let x = pX[i], y = pY[i], z = pZ[i];
                let x1 = x * cosY - z * sinY;
                let z1 = x * sinY + z * cosY;
                let y1 = y * cosX - z1 * sinX;
                let z2 = y * sinX + z1 * cosX;
                x = x1; y = y1; z = z2;

                // --- Rotate base position ---
                let bx = bX[i], by = bY[i], bz = bZ[i];
                let bx1 = bx * cosY - bz * sinY;
                let bz1 = bx * sinY + bz * cosY;
                let by1 = by * cosX - bz1 * sinX;
                let bz2 = by * sinX + bz1 * cosX;
                bX[i] = bx1; bY[i] = by1; bZ[i] = bz2;

                // Subtle breathing bulge + traveling ripple on sphere surface
                const baseLenSq = (bx1 * bx1) + (by1 * by1) + (bz2 * bz2);
                const invBaseLen = baseLenSq > 0 ? 1 / Math.sqrt(baseLenSq) : 1;
                const lat = by1 / sR;
                const lon = Math.atan2(bz2, bx1);
                const rippleWave = Math.sin(
                    (lat * surfaceEffect.frequency) +
                    (lon * surfaceEffect.twist) -
                    (timeSec * surfaceEffect.speed)
                );
                const radialScale = 1 + surfaceEffect.bulge + (rippleWave * surfaceEffect.ripple);
                const tx = bx1 * radialScale;
                const ty = by1 * radialScale;
                const tz = bz2 * radialScale;

                // Nudge current particle toward the animated surface target
                x += (tx - x) * (0.18 * invBaseLen * sR);
                y += (ty - y) * (0.18 * invBaseLen * sR);
                z += (tz - z) * (0.18 * invBaseLen * sR);

                // --- Project to screen ---
                const scale = fov / (fov + z + sR);
                const screenX = x * scale + halfW;
                const screenY = y * scale + halfH;

                // --- Mouse interaction ---
                if (hasMouse) {
                    const dx = screenX - mx;
                    const dy = screenY - my;
                    const distSq = dx * dx + dy * dy;
                    if (distSq < mRSq && z < 0) {
                        const dist = Math.sqrt(distSq) || 1;
                        const force = (mR - dist) / mR;
                        const d = pDensity[i];
                        x += (dx / dist) * force * d * 9.5;
                        y += (dy / dist) * force * d * 9.5;
                    }
                }

                // --- Spring back ---
                pX[i] = x + (tx - x) * 0.075;
                pY[i] = y + (ty - y) * 0.075;
                pZ[i] = z + (tz - z) * 0.075;

                // --- Cull off-screen particles ---
                const drawSize = BASE_SIZE * scale * 1.75 * 3; // includes glow radius
                if (screenX < -drawSize || screenX > W + drawSize ||
                    screenY < -drawSize || screenY > H + drawSize) {
                    continue;
                }

                // --- Draw using pre-rendered sprite ---
                const depth = (z + sR) / sR2;
                const bucket = (depth * (DEPTH_BUCKETS - 1) + 0.5) | 0; // fast round + clamp
                const clampedBucket = bucket < 0 ? 0 : bucket >= DEPTH_BUCKETS ? DEPTH_BUCKETS - 1 : bucket;
                const phaseBase = ((timeSec * 1.75) + (lat * 2.4) + (lon * 0.75)) * IRIDESCENT_PHASES;
                const phaseIdx = ((phaseBase | 0) % IRIDESCENT_PHASES + IRIDESCENT_PHASES) % IRIDESCENT_PHASES;
                const sprite = spriteCache[phaseIdx][clampedBucket];

                const radius = BASE_SIZE * scale * 1.75;
                const spriteScale = radius / 4; // 4 = coreR used when building sprite
                const drawW = sprite.canvas.width * spriteScale;
                const drawH = sprite.canvas.height * spriteScale;

                ctx.drawImage(
                    sprite.canvas,
                    (screenX - drawW * 0.5 + 0.5) | 0,
                    (screenY - drawH * 0.5 + 0.5) | 0,
                    (drawW + 0.5) | 0,
                    (drawH + 0.5) | 0
                );
            }

            requestAnimationFrame(animate);
        }

        resize();
        animate();
    </script>
</body>
</html>